<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>–ë—è–∫–æ–•–æ–¥ ‚Äî –ú–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #copyright a {
      text-decoration: none;
      color: #0066cc;
      font-weight: bold;
      border: none;
      background: transparent;
      padding: 0;
      text-shadow:
        -1px -1px 0 #888,
         1px -1px 0 #888,
        -1px  1px 0 #888,
         1px  1px 0 #888;
    }
    #copyright a:hover {
      text-shadow:
        -1px -1px 0 #aaa,
         1px -1px 0 #aaa,
        -1px  1px 0 #aaa,
         1px  1px 0 #aaa;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: Calibri, Arial, sans-serif;
      overflow: hidden;
    }
    #map {
      width: 100%;
      height: 100vh;
      cursor: default;
    }
    /* –ö–Ω–æ–ø–∫–∞ –º–µ–Ω—é */
    #menu-button {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: white;
      border: 2px solid #ccc;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
    #menu-button span {
      display: block;
      width: 4px;
      height: 4px;
      background: #333;
      border-radius: 50%;
      margin: 1px 0;
    }
    /* Zoom control */
    #zoom-control {
      position: absolute;
      top: 16px;
      left: 80px;
      display: flex;
      gap: 4px;
      z-index: 1000;
    }
    .zoom-btn {
      width: 30px;
      height: 30px;
      background: white;
      border: 2px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    }
    .zoom-btn:hover {
      background: #f0f0f0;
    }
    /* –ê–≤—Ç–æ—Ä—Å–∫–∏–µ –ø—Ä–∞–≤–∞ */
    #copyright {
      position: absolute;
      top: 18px;
      left: 160px;
      z-index: 1000;
      font-size: 13px;
    }
    #copyright span {
      display: inline-block;
      color: #0066cc;
      font-weight: bold;
      border: none;
      background: transparent;
      padding: 0;
      text-shadow:
        -1px -1px 0 #888,
         1px -1px 0 #888,
        -1px  1px 0 #888,
         1px  1px 0 #888;
    }
    /* –í—ã–ø–∞–¥–∞—é—â–µ–µ –º–µ–Ω—é */
    #dropdown-menu {
      display: none;
      position: absolute;
      top: 55px;
      left: 10px;
      background: #e8e8e8;
      padding: 16px 2px;
      border-radius: 8px;
      box-shadow: 0 0 12px rgba(0,0,0,0.5);
      z-index: 1000;
      width: fit-content;
      font-size: 14px;
      font-family: Calibri, Arial, sans-serif;
    }
    #dropdown-menu.active {
      display: block;
    }
    .menu-section {
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .menu-label {
      display: block;
      font-weight: bold;
      color: #222;
      margin-bottom: 6px;
      text-shadow: 0 0 4px white, 0 0 6px white;
      font-family: Calibri, Arial, sans-serif;
    }
    input[type="text"],
    select {
      width: auto;
      min-width: 0;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #999;
      border-radius: 4px;
      box-sizing: border-box;
      background: white;
      font-family: Calibri, Arial, sans-serif;
    }
    .menu-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: bold;
      font-size: 14px;
      background: #dcdcdc;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      padding: 10px 12px;
      white-space: nowrap;
      font-family: Calibri, Arial, sans-serif;
    }
    .menu-btn:hover {
      background: #ccc;
    }
    .load-route-container {
      display: flex;
      gap: 6px;
      align-items: center;
      width: fit-content;
    }
    #load-route {
      width: auto;
      max-width: max-content;
      padding: 10px 12px;
      white-space: nowrap;
    }
    #file-input {
      display: none;
    }
    #status {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: #e8e8e8;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      color: #222;
      z-index: 1000;
      max-width: 300px;
      line-height: 1.4;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
      font-family: Calibri, Arial, sans-serif;
    }
    .route-distance {
      color: red;
      font-weight: bold;
    }
    #clear-route-btn {
      position: absolute;
      bottom: 70px;
      left: 12px;
      padding: 8px 12px;
      font-size: 14px;
      background: #dcdcdc;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
      font-weight: bold;
      font-family: Calibri, Arial, sans-serif;
    }
    #clear-route-btn:hover {
      background: #ccc;
    }
    #map.clickable {
      cursor: crosshair;
    }
    .leaflet-control-attribution {
      display: none !important;
    }
    /* –°—Ç–∏–ª–∏ –¥–ª—è overlay */
    #loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 3000;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    #loading-overlay.show {
      display: flex;
      pointer-events: auto;
    }
    #loading-modal {
      background: white;
      padding: 30px 40px;
      border-radius: 15px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 8px 25px rgba(0,0,0,0.8);
      font-family: Calibri, Arial, sans-serif;
      border: 3px solid #ff6b6b;
      color: #333;
      min-width: 250px;
    }
    #show-route-points-btn {
      position: absolute;
      bottom: 12px;
      right: 12px;
      padding: 8px 12px;
      background: #dcdcdc;
      border: 1px solid #aaa;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      z-index: 1000;
      display: none;
    }
    .user-point-label {
      background: #ffe0e0;
      border: 1px solid #cc6666;
      border-radius: 3px;
      font-size: 14px;
      font-weight: bold;
      color: #000;
      padding: 2px;
      white-space: nowrap;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      position: relative;
      display: inline-block;
      line-height: 1;
      z-index: 600;
    }
    /* –ü–æ–¥–ø–∏—Å–∏ –ø–∏–∫–µ—Ç–æ–≤ –ø—Ä—è–º–æ –Ω–∞ –∫–∞—Ä—Ç–µ */
    .route-point-label {
      background: #e3f2fd;
      border: 1px solid #90caf9;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      color: #01579b;
      padding: 2px;
      white-space: pre-line;
      word-wrap: break-word;
      word-break: normal;
      max-width: none;
      min-width: 20px;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      display: inline-block;
      line-height: 1.2;
      writing-mode: horizontal-tb;
      text-orientation: mixed;
      z-index: 600;
    }
    .route-point-item {
      cursor: pointer;
      padding: 2px 0;
    }
    .route-point-item:hover {
      background-color: #f0f0f0;
      border-radius: 3px;
    }
    /* === –í–µ—Ä—Ö–Ω–∏–µ –ø—Ä–∞–≤—ã–µ –∫–Ω–æ–ø–∫–∏: –õ–µ–≥–µ–Ω–¥–∞ + Undo + –ü–æ–∏—Å–∫ === */
    #top-right-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 8px;
      z-index: 1002;
    }
    #top-right-controls button {
      width: 40px;
      height: 40px;
      background: white;
      border: 2px solid #ccc;
      border-radius: 6px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
      font-size: 20px;
      color: #333;
      padding: 0;
      margin: 0;
      font-weight: bold;
      line-height: 1;
    }
    #top-right-controls button:hover {
      background: #f0f0f0;
    }
    #legend-btn {
      font-size: 18px;
    }
    #undo-btn {
      font-size: 24px;
      display: none;
    }
    /* –ü–∞–Ω–µ–ª—å –ª–µ–≥–µ–Ω–¥—ã */
    #legend-panel {
      position: absolute;
      top: 58px;
      right: 12px;
      width: 220px;
      background: white;
      border: 2px solid #aaa;
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 1003;
      display: none;
      font-family: Calibri, Arial, sans-serif;
    }
    #legend-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #222;
      text-align: center;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-size: 12px;
    }
    .legend-color {
      width: 20px;
      height: 8px;
      margin-right: 8px;
      border-radius: 2px;
    }
    /* –í—Å–ø–ª—ã–≤–∞—é—â–∞—è –ø–∞–Ω–µ–ª—å –ø–æ–∏—Å–∫–∞ */
    #search-panel {
      position: absolute;
      top: 58px;
      right: 12px;
      width: 220px;
      display: none;
      z-index: 1003;
    }
    #search-input {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid #aaa;
      border-radius: 4px;
      font-size: 14px;
      font-family: Calibri, Arial, sans-serif;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #search-results {
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 2px solid #aaa;
      border-top: none;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      display: none;
    }
    .search-result-item {
      padding: 6px 12px;
      cursor: pointer;
      font-size: 14px;
      font-family: Calibri, Arial, sans-serif;
      border-bottom: 1px solid #eee;
    }
    .search-result-item:hover {
      background-color: #f0f8ff;
    }
    /* –°—Ç–∏–ª–∏ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ø–∞–Ω–µ–ª–∏ "–ù–∏—Ç–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞" */
    .route-point-item {
      padding: 4px 8px;
      cursor: pointer;
      font-size: 13px;
      font-family: Calibri, Arial, sans-serif;
      border-bottom: 1px solid #bbdefb;
      background-color: #e3f2fd;
      color: #01579b;
      border-radius: 4px;
      margin: 2px 0;
      white-space: normal;
      word-wrap: break-word;
      word-break: keep-all;
      line-height: 1.3;
    }
    .route-point-item:hover {
      background-color: #b3e5fc;
    }
    /* –°—Ç–∏–ª–∏ –¥–ª—è —Å–ª–æ–µ–≤ Leaflet */
    .leaflet-overlay-pane {
      z-index: 500 !important;
    }
    .leaflet-marker-pane {
      z-index: 600 !important;
    }
    .leaflet-popup-pane {
      z-index: 700 !important;
    }
  </style>
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
  	(function(m,e,t,r,i,k,a){
  		m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
		m[i].l=1*new Date();
		for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
		k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
	})(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105491546', 'ym');

		ym(105491546, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/105491546" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

</head>
<body>
<div id="menu-button">
  <span></span>
  <span></span>
  <span></span>
</div>
<div id="zoom-control">
  <div class="zoom-btn" id="zoom-in">+</div>
  <div class="zoom-btn" id="zoom-out">‚àí</div>
</div>
<div id="copyright">
  <a href="https://t.me/Aleks_Donor" target="_blank" rel="noopener">
    ¬© by Alex Donor
  </a>
</div>
<div id="dropdown-menu">
  <div class="menu-section">
    <span class="menu-label">–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É:</span>
    <select id="background-select">
      <option value="maps/byaki.png">–ë–∞–∑–æ–≤–∞—è –∫–∞—Ä—Ç–∞</option>
      <option value="maps/map2.png">–ö–∞—Ä—Ç–∞ —Å –∑–∞–ª–∏–≤–∫–æ–π</option>
    </select>
  </div>
  <div class="menu-section">
    <span class="menu-label">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç:</span>
    <div style="display: flex; gap: 6px; align-items: center;">
      <input type="text" id="route-name" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ" value="–ú–æ–π –º–∞—Ä—à—Ä—É—Ç">
      <button class="menu-btn" id="save-route">üíæ</button>
    </div>
  </div>
  <div class="menu-section">
    <span class="menu-label"> –ó–∞–≥—Ä—É–∑–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç:</span>
    <div class="load-route-container">
      <button class="menu-btn" id="load-route">üìÅ –í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª...</button>
      <input type="file" id="file-input" accept=".json">
    </div>
  </div>
  <div class="menu-section">
    <button class="menu-btn" id="show-disclaimer">‚ÑπÔ∏è –û—Ç–∫–∞–∑ –æ—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏</button>
  </div>
</div>
<button id="clear-route-btn">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç</button>
<div id="top-right-controls">
  <button id="legend-btn" title="–õ–µ–≥–µ–Ω–¥–∞ –º–∞—Ä—à—Ä—É—Ç–∞">‚ÑπÔ∏è</button>
  <button id="undo-btn" title="–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É">‚Ü©Ô∏è</button>
  <button id="search-btn">üîç</button>
</div>
<div id="legend-panel">
  <h3>–¢–∏–ø—ã –ø—Ä–æ—Ö–æ–¥–æ–≤</h3>
  <div class="legend-item">
    <div class="legend-color" style="background-color: #00FF00;"></div>
    <span>–°–≤–æ–±–æ–¥–Ω—ã–π –ø—Ä–æ—Ö–æ–¥</span>
  </div>
   <div class="legend-item">
    <div class="legend-color" style="background-color: #FFA500;"></div>
    <span>–ü—Ä–æ—Ö–æ–¥ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ–º</span>
  </div>
  <div class="legend-item">
    <div class="legend-color" style="background-color: #FF0000;"></div>
    <span>–®–∫—É—Ä–æ–¥–µ—Ä</span>
  </div>
  <div class="legend-item">
    <div class="legend-color" style="background-color: #0000FF;"></div>
    <span>–û–±–≤–æ–¥–Ω–µ–Ω–Ω—ã–π —à—Ç—Ä–µ–∫</span>
  </div>
</div>
<div id="search-panel">
  <input type="text" id="search-input" placeholder="–ü–æ–∏—Å–∫ —Ç–æ—á–µ–∫...">
  <div id="search-results"></div>
</div>
<div id="map"></div>
<div id="status">–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç—ã...</div>
<div id="loading-overlay">
  <div id="loading-modal">–ü–æ–¥–æ–∂–¥–∏—Ç–µ!<br>–ú–∞—Ä—à—Ä—É—Ç —Å—Ç—Ä–æ–∏—Ç—Å—è</div>
</div>
<button id="show-route-points-btn">üìç</button>
<div id="disclaimer-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 3000; justify-content: center; align-items: center;">
  <div style="
    background: white;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
    font-family: Calibri, Arial, sans-serif;
    font-size: 15px;
    line-height: 1.6;
    position: relative;
  ">
    <h3 style="margin-top: 0; margin-bottom: 16px; color: #222; text-align: center;">–û—Ç–∫–∞–∑ –æ—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏</h3>
    <div style="text-align: justify; hyphens: auto; -webkit-hyphens: auto; -moz-hyphens: auto;">
      <p style="text-indent: 1.5em; margin-top: 0; margin-bottom: 1em;">–ù–∞—Å—Ç–æ—è—â–µ–µ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ (–¥–∞–ª–µ–µ ‚Äî –ü—Ä–æ–¥—É–∫—Ç) —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–æ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –≤ –Ω–µ–∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö –∏ —Ä–∞–∑–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–µ–ª—è—Ö –∏ –Ω–µ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–æ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞–∫–æ–π-–ª–∏–±–æ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –∏–ª–∏ –Ω–µ–ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å –ø—Ä–µ–±—ã–≤–∞–Ω–∏–µ–º –∏–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º —Ä–∞–±–æ—Ç –ø–æ–¥ –∑–µ–º–ª—ë–π, –≤–∫–ª—é—á–∞—è, –Ω–æ –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—è—Å—å: —Å–ø–µ–ª–µ–æ–ª–æ–≥–∏–µ–π, –ø–æ–¥–∑–µ–º–Ω—ã–º —Ç—É—Ä–∏–∑–º–æ–º, –≥–æ—Ä–Ω—ã–º–∏, —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–º–∏, –∞–≤–∞—Ä–∏–π–Ω–æ-—Å–ø–∞—Å–∞—Ç–µ–ª—å–Ω—ã–º–∏ –∏ –∏–Ω—ã–º–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–º–∏ –≤–∏–¥–∞–º–∏ –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.</p>
      <p style="text-indent: 1.5em; margin-top: 0; margin-bottom: 1em;">–ê–≤—Ç–æ—Ä –ü—Ä–æ–¥—É–∫—Ç–∞ –Ω–µ –¥–∞—ë—Ç –Ω–∏–∫–∞–∫–∏—Ö –≥–∞—Ä–∞–Ω—Ç–∏–π –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–æ—á–Ω–æ—Å—Ç–∏, –ø–æ–ª–Ω–æ—Ç—ã, –¥–æ—Å—Ç–æ–≤–µ—Ä–Ω–æ—Å—Ç–∏ –∏–ª–∏ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤, –∫–∞—Ä—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π. –í—Å–µ –¥–∞–Ω–Ω—ã–µ –Ω–æ—Å—è—Ç –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω—ã–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –∏ –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç–∏.</p>
      <p style="text-indent: 1.5em; margin-top: 0; margin-bottom: 1em;">–ê–≤—Ç–æ—Ä –Ω–µ –Ω–µ—Å—ë—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –∑–∞ –ª—é–±–æ–π —É—â–µ—Ä–±, —É–±—ã—Ç–∫–∏, —Ç—Ä–∞–≤–º—ã –∏–ª–∏ –∏–Ω—ã–µ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–µ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è, –≤–æ–∑–Ω–∏–∫—à–∏–µ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ü—Ä–æ–¥—É–∫—Ç–∞, –≤ —Ç–æ–º —á–∏—Å–ª–µ –ø—Ä–∏ –µ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –≤ —É—Å–ª–æ–≤–∏—è—Ö, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å —Ä–∏—Å–∫–æ–º –¥–ª—è –∂–∏–∑–Ω–∏ –∏ –∑–¥–æ—Ä–æ–≤—å—è.</p>
      <p style="text-indent: 1.5em; margin-top: 0; margin-bottom: 1em;">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç, —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ü—Ä–æ–¥—É–∫—Ç –Ω–∞ —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä–∏—Å–∫ –∏ –æ—Å–æ–∑–Ω–∞—ë—Ç, —á—Ç–æ –æ–Ω –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –≤ –∫–∞—á–µ—Å—Ç–≤–µ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–ª–∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Å—Ä–µ–¥—Å—Ç–≤–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏–ª–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥–∑–µ–º–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤.</p>
    </div>
    <div style="text-align: center; margin-top: 24px;">
      <button id="close-disclaimer" style="
        padding: 10px 24px;
        font-size: 16px;
        background: #dcdcdc;
        border: 1px solid #aaa;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        min-width: 120px;
      ">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>
</div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
  let pointsGeoJsonData = null;
  let routesGeoJsonData = null;
  let isBuildingRoute = false;
  
  // –ö–û–ù–°–¢–ê–ù–¢–ê –ö–ê–õ–ò–ë–†–û–í–ö–ò –ú–ê–°–®–¢–ê–ë–ê
  // –ù–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–∏—Ö –∏–∑–º–µ—Ä–µ–Ω–∏–π: 84–º –≤ QGIS = 145.9px –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏
  const SCALE_CORRECTION = 84 / 145.9; // ‚âà 0.5757

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –≤ –º–µ—Ç—Ä–∞—Ö
  function calculateRealDistance(coord1, coord2) {
    const dx = coord1[0] - coord2[0];
    const dy = coord1[1] - coord2[1];
    const pixelDistance = Math.sqrt(dx * dx + dy * dy);
    return pixelDistance * SCALE_CORRECTION;
  }

  // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  function checkImageExists(url, callback) {
    const img = new Image();
    img.onload = function() { callback(true); };
    img.onerror = function() { callback(false); };
    img.src = url;
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∫–∞—Ä—Ç
  checkImageExists('maps/byaki.png', function(exists) {
    console.log('–ö–∞—Ä—Ç–∞ byaki.png –¥–æ—Å—Ç—É–ø–Ω–∞:', exists);
    if (!exists) {
      console.error('–ö–∞—Ä—Ç–∞ maps/byaki.png –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!');
    }
  });
  checkImageExists('maps/map2.png', function(exists) {
    console.log('–ö–∞—Ä—Ç–∞ map2.png –¥–æ—Å—Ç—É–ø–Ω–∞:', exists);
    if (!exists) {
      console.error('–ö–∞—Ä—Ç–∞ maps/map2.png –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!');
    }
  });

  // –§—É–Ω–∫—Ü–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏/—Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
  function setUIEnabled(enabled) {
    const elements = [
      '#menu-button',
      '#zoom-control .zoom-btn',
      '#clear-route-btn',
      '#undo-btn',
      '#search-btn',
      '#legend-btn'
    ];
    
    elements.forEach(selector => {
        const element = document.querySelector(selector);
        if (element) {
            if (enabled) {
                element.style.pointerEvents = 'auto';
                element.style.opacity = '1';
            } else {
                element.style.pointerEvents = 'none';
                element.style.opacity = '0.5';
            }
        }
    });
    
    // –ë–ª–æ–∫–∏—Ä—É–µ–º/—Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É
    const mapContainer = map.getContainer();
    if (enabled) {
        mapContainer.style.pointerEvents = 'auto';
    } else {
        mapContainer.style.pointerEvents = 'none';
    }
  }

  // –ó–∞–º–µ–Ω–∏–º Android-—Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞ –≤–µ–±-–≤–µ—Ä—Å–∏–∏
  window.Android = {
    loadGeoJson: async function() {
      try {
        if (routesGeoJsonData) {
          return JSON.stringify(routesGeoJsonData);
        }
        console.log('–ó–∞–≥—Ä—É–∂–∞–µ–º routes.geojson...');
        const response = await fetch('data/routes.geojson');
        if (!response.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å routes.geojson');
        const data = await response.json();
        routesGeoJsonData = data;
        console.log('routes.geojson –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ');
        return JSON.stringify(data);
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ routes.geojson:', error);
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        const testData = {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: [[100, 100], [500, 100], [500, 500], [100, 500], [100, 100]]
              },
              properties: {
                weight: 5
              }
            }
          ]
        };
        return JSON.stringify(testData);
      }
    },
    loadPointsGeoJson: async function() {
      try {
        if (pointsGeoJsonData) {
          return JSON.stringify(pointsGeoJsonData);
        }
        console.log('–ó–∞–≥—Ä—É–∂–∞–µ–º points.geojson...');
        const response = await fetch('data/points.geojson');
        if (!response.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å points.geojson');
        const data = await response.json();
        pointsGeoJsonData = data;
        console.log('points.geojson –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ');
        return JSON.stringify(data);
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ points.geojson:', error);
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        const testData = {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [300, 300]
              },
              properties: {
                Name: "–¢–µ—Å—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞"
              }
            }
          ]
        };
        return JSON.stringify(testData);
      }
    },
    saveRoute: function(name, json) {
      const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name.replace(/[^\w–∞-—è–ê-–Ø—ë–Å\s.-]/g, '_').replace(/\s+/g, '_') + '.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    },
    requestLoadRoute: function() {
      document.getElementById('file-input').click();
    }
  };

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã
  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: 0.05,
    maxZoom: 4,
    zoomControl: false
  });

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ z-index –¥–ª—è —Å–ª–æ–µ–≤
  map.createPane('routes');
  map.getPane('routes').style.zIndex = 500;
  map.createPane('markers');
  map.getPane('markers').style.zIndex = 600;
  map.createPane('labels');
  map.getPane('labels').style.zIndex = 700;

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∑—É–º–∞
  document.getElementById('zoom-in').addEventListener('click', () => {
    if (map.getZoom() < map.getMaxZoom()) map.zoomIn();
  });
  document.getElementById('zoom-out').addEventListener('click', () => {
    if (map.getZoom() > map.getMinZoom()) map.zoomOut();
  });

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
  function distToSegment(p, v, w) {
    const dx = w[0] - v[0];
    const dy = w[1] - v[1];
    const l2 = dx * dx + dy * dy;
    if (l2 === 0) return calculateRealDistance(p, v);
    let t = ((p[0] - v[0]) * dx + (p[1] - v[1]) * dy) / l2;
    t = Math.max(0, Math.min(1, t));
    const proj = [v[0] + t * dx, v[1] + t * dy];
    return calculateRealDistance(p, proj);
  }

  // segments —Ç–µ–ø–µ—Ä—å —Å–æ–¥–µ—Ä–∂–∏—Ç –º–∞—Å—Å–∏–≤—ã [start, end, weight]
  let segments = [];
  let graph = {};
  let selectedPoints = [];
  let pointMarkers = [];
  let userLabelMarkers = [];
  let routeLabelMarkers = [];
  let routePointMarkers = [];
  let routeLayer = null;
  let currentImageOverlay = null;
  let mapBounds = null;
  let menuOpen = false;
  let currentRoutePointsPopup = null;
  window.temporaryHighlightMarker = null;
  const CURSOR_TOLERANCE_PX = 1;
  let routeLabelsVisible = true;
  let allPointsGeoJson = null;

  // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ–¥–ø–∏—Å–µ–π
  function updateLabelVisibility() {
    const routeLabels = routeLabelMarkers.filter(marker => map.hasLayer(marker));
    const userLabels = userLabelMarkers.filter(marker => map.hasLayer(marker));
    if (routeLabels.length === 0 && userLabels.length === 0) return;
    
    const labelInfo = [];
    
    for (const marker of userLabels) {
      const latlng = marker.getLatLng();
      const el = marker._icon;
      if (!el) continue;
      const point = map.latLngToContainerPoint(latlng);
      let w = Math.max(el.offsetWidth || 30, 30);
      let h = Math.max(el.offsetHeight || 15, 15);
      labelInfo.push({
        marker,
        isUser: true,
        x: point.x,
        y: point.y,
        w,
        h,
        rect: [point.x, point.y, point.x + w, point.y + h]
      });
    }
    
    for (const marker of routeLabels) {
      const latlng = marker.getLatLng();
      const el = marker._icon;
      if (!el) continue;
      const point = map.latLngToContainerPoint(latlng);
      let w = Math.max(el.offsetWidth || 40, 40);
      let h = Math.max(el.offsetHeight || 20, 20);
      labelInfo.push({
        marker,
        isUser: false,
        x: point.x,
        y: point.y,
        w,
        h,
        rect: [point.x, point.y, point.x + w, point.y + h]
      });
    }
    
    if (labelInfo.length === 0) return;
    
    const toHide = new Set();
    for (let i = 0; i < labelInfo.length; i++) {
      for (let j = i + 1; j < labelInfo.length; j++) {
        const a = labelInfo[i];
        const b = labelInfo[j];
        const r1 = a.rect;
        const r2 = b.rect;
        const overlap = !(r1[2] < r2[0] || r2[2] < r1[0] || r1[3] < r2[1] || r2[3] < r1[1]);
        if (overlap) {
          if (a.isUser && b.isUser) continue;
          if (a.isUser && !b.isUser) {
            toHide.add(b.marker);
          } else if (!a.isUser && b.isUser) {
            toHide.add(a.marker);
          } else if (!a.isUser && !b.isUser) {
            toHide.add(b.marker);
          }
        }
      }
    }
    
    routeLabels.forEach(marker => {
      if (toHide.has(marker)) {
        map.removeLayer(marker);
      } else {
        if (!map.hasLayer(marker)) map.addLayer(marker);
      }
    });
    
    userLabels.forEach(marker => {
      if (!map.hasLayer(marker)) {
        map.addLayer(marker);
      }
    });
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ —Å –ø–µ—Ä–µ–Ω–æ—Å–∞–º–∏
  function formatTextWithLineBreaks(text) {
    if (text.length <= 12) {
      return text;
    }
    
    if (text.includes(' ')) {
      const words = text.split(' ');
      let lines = [];
      let currentLine = '';
      for (let i = 0; i < words.length; i++) {
        const word = words[i];
        if (currentLine === '') {
          currentLine = word;
        } else if (currentLine.length + word.length + 1 <= 12) {
          currentLine += ' ' + word;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      if (currentLine !== '') {
        lines.push(currentLine);
      }
      return lines.join('\n');
    }
    
    if (text.length > 15) {
      const mid = Math.ceil(text.length / 2);
      return text.substring(0, mid) + '\n' + text.substring(mid);
    }
    return text;
  }

  function createLabelMarker(latlng, text, className, offsetX, offsetY) {
    const div = document.createElement('div');
    div.className = className;
    const formattedText = formatTextWithLineBreaks(text);
    div.textContent = formattedText;
    
    const tempDiv = document.createElement('div');
    tempDiv.className = className;
    tempDiv.textContent = formattedText;
    tempDiv.style.position = 'absolute';
    tempDiv.style.visibility = 'hidden';
    tempDiv.style.whiteSpace = 'pre-line';
    tempDiv.style.wordWrap = 'break-word';
    tempDiv.style.wordBreak = 'normal';
    tempDiv.style.maxWidth = 'none';
    tempDiv.style.minWidth = '20px';
    tempDiv.style.padding = '2px';
    tempDiv.style.fontSize = '12px';
    tempDiv.style.fontWeight = 'bold';
    tempDiv.style.fontFamily = 'Calibri, Arial, sans-serif';
    tempDiv.style.lineHeight = '1.2';
    tempDiv.style.boxSizing = 'border-box';
    document.body.appendChild(tempDiv);
    
    const width = tempDiv.scrollWidth + 2;
    const height = tempDiv.scrollHeight;
    document.body.removeChild(tempDiv);
    
    const icon = L.divIcon({
      className: '',
      html: div.outerHTML,
      iconSize: [width, height],
      iconAnchor: [-offsetX, -offsetY]
    });
    
    return L.marker(latlng, {
      icon: icon,
      interactive: false,
      zIndexOffset: 1000,
      pane: 'labels'
    });
  }

  function toggleRouteLabels() {
    const zoom = map.getZoom();
    const shouldShow = zoom >= 2 && routeLabelsVisible;
    routeLabelMarkers.forEach(marker => {
      if (shouldShow) {
        if (!map.hasLayer(marker)) map.addLayer(marker);
      } else {
        if (map.hasLayer(marker)) map.removeLayer(marker);
      }
    });
    setTimeout(() => {
      updateLabelVisibility();
    }, 100);
  }

  map.on('zoomend', toggleRouteLabels);

  function handleMouseMove(e) {
    const container = map.getContainer();
    container.classList.remove('clickable');
    if (segments.length === 0) return;
    const mouse = [e.latlng.lng, e.latlng.lat];
    const p1 = map.containerPointToLayerPoint([0, 0]);
    const p2 = map.containerPointToLayerPoint([CURSOR_TOLERANCE_PX, 0]);
    const tolerance = Math.abs(p2.x - p1.x) * SCALE_CORRECTION;
    
    for (let i = 0; i < segments.length; i++) {
      if (distToSegment(mouse, segments[i][0], segments[i][1]) <= tolerance) {
        container.classList.add('clickable');
        return;
      }
    }
  }

  map.on('mousemove', handleMouseMove);

  function updateUndoButtonVisibility() {
    const undoBtn = document.getElementById('undo-btn');
    if (selectedPoints.length > 0) {
      undoBtn.style.display = 'flex';
    } else {
      undoBtn.style.display = 'none';
    }
  }

  function clearRoute() {
    if (routeLayer) map.removeLayer(routeLayer);
    pointMarkers.forEach(marker => map.removeLayer(marker));
    userLabelMarkers.forEach(marker => map.removeLayer(marker));
    routeLabelMarkers.forEach(marker => map.removeLayer(marker));
    routePointMarkers.forEach(marker => map.removeLayer(marker));
    routeLayer = null;
    selectedPoints = [];
    pointMarkers = [];
    userLabelMarkers = [];
    routeLabelMarkers = [];
    routePointMarkers = [];
    if (window.temporaryHighlightMarker) {
      map.removeLayer(window.temporaryHighlightMarker);
      window.temporaryHighlightMarker = null;
    }
    document.getElementById('status').textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å—Ö–µ–º—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ—á–µ–∫ –º–∞—Ä—à—Ä—É—Ç–∞';
    map.getContainer().classList.remove('clickable');
    if (currentRoutePointsPopup) {
      currentRoutePointsPopup.remove();
      currentRoutePointsPopup = null;
    }
    document.getElementById('show-route-points-btn').style.display = 'none';
    document.getElementById('show-route-points-btn').textContent = 'üìç';
    updateUndoButtonVisibility();
  }

  function dijkstra(graph, start, end) {
    if (start === end) {
      return [start.split(',').map(Number)];
    }
    if (!graph[start] || !graph[end]) return null;
    
    const dist = {};
    const prev = {};
    const unvisited = new Set();
    
    for (const node in graph) {
      dist[node] = node === start ? 0 : Infinity;
      unvisited.add(node);
    }
    
    while (unvisited.size > 0) {
      let current = null;
      let minDist = Infinity;
      for (const node of unvisited) {
        if (dist[node] < minDist) {
          minDist = dist[node];
          current = node;
        }
      }
      if (current === end || minDist === Infinity) break;
      unvisited.delete(current);
      
      for (const neighbor in graph[current]) {
        if (unvisited.has(neighbor)) {
          const alt = dist[current] + graph[current][neighbor];
          if (alt < dist[neighbor]) {
            dist[neighbor] = alt;
            prev[neighbor] = current;
          }
        }
      }
    }
    
    if (dist[end] === Infinity) return null;
    
    const path = [];
    let u = end;
    while (u !== undefined) {
      path.unshift(u.split(',').map(Number));
      if (u === start) break;
      u = prev[u];
    }
    return path.length > 0 ? path : null;
  }

  function findPointsNearRoute(routeCoords, pointsGeoJson, maxDistance = 2.5) {
    const segments = [];
    let totalLength = 0;
    for (let i = 0; i < routeCoords.length - 1; i++) {
      const a = routeCoords[i];
      const b = routeCoords[i + 1];
      const len = calculateRealDistance(a, b);
      segments.push({ start: a, end: b, length: len, startDist: totalLength });
      totalLength += len;
    }
    
    const nearbyPoints = [];
    const addedPointKeys = new Set();
    
    function getPointKey(coords) {
      return `${coords[0].toFixed(3)},${coords[1].toFixed(3)}`;
    }
    
    for (let segIndex = 0; segIndex < segments.length; segIndex++) {
      const seg = segments[segIndex];
      const { start, end } = seg;
      const dx = end[0] - start[0];
      const dy = end[1] - start[1];
      const l2 = dx * dx + dy * dy;
      
      pointsGeoJson.features.forEach(feature => {
        if (feature.geometry.type !== "Point") return;
        const pt = feature.geometry.coordinates;
        const name = feature.properties?.Name;
        if (name == null || !Array.isArray(pt) || pt.length < 2) return;
        
        const pointKey = getPointKey(pt);
        if (addedPointKeys.has(pointKey)) return;
        
        let dist;
        if (l2 === 0) {
          dist = calculateRealDistance(pt, start);
        } else {
          const t = Math.max(0, Math.min(1, ((pt[0] - start[0]) * dx + (pt[1] - start[1]) * dy) / l2));
          const projX = start[0] + t * dx;
          const projY = start[1] + t * dy;
          dist = calculateRealDistance(pt, [projX, projY]);
        }
        
        if (dist <= maxDistance) {
          const t = l2 === 0 ? 0 : Math.max(0, Math.min(1, ((pt[0] - start[0]) * dx + (pt[1] - start[1]) * dy) / l2));
          const alongDist = seg.startDist + t * Math.sqrt(l2) * SCALE_CORRECTION;
          nearbyPoints.push({ name, coords: pt, alongDist });
          addedPointKeys.add(pointKey);
        }
      });
    }
    
    nearbyPoints.sort((a, b) => a.alongDist - b.alongDist);
    return nearbyPoints.map(p => ({ name: p.name, coords: p.coords }));
  }

  async function buildFullRoute() {
    if (selectedPoints.length < 2 || isBuildingRoute) return;
    
    isBuildingRoute = true;
    
    if (currentRoutePointsPopup) {
        currentRoutePointsPopup.remove();
        currentRoutePointsPopup = null;
    }
    
    routeLabelMarkers.forEach(m => map.removeLayer(m));
    routeLabelMarkers = [];
    routePointMarkers.forEach(m => map.removeLayer(m));
    routePointMarkers = [];

    // –ü–û–ö–ê–ó–´–í–ê–ï–ú OVERLAY –ò –ë–õ–û–ö–ò–†–£–ï–ú –ò–ù–¢–ï–†–§–ï–ô–°
    console.log("–ü–æ–∫–∞–∑—ã–≤–∞–µ–º overlay –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞");
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';
    loadingOverlay.classList.add('show');
    
    setUIEnabled(false);

    try {
        if (routeLayer) map.removeLayer(routeLayer);
        routeLayer = null;
        const fullPath = [];
        let totalDistance = 0;
        let valid = true;
        
        // –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ overlay
        await new Promise(resolve => setTimeout(resolve, 100));
        
        for (let i = 0; i < selectedPoints.length - 1; i++) {
            const start = selectedPoints[i];
            const end = selectedPoints[i + 1];
            const startKey = start.join(',');
            const endKey = end.join(',');
            let segmentPath = null;
            
            if (startKey === endKey) {
                segmentPath = [start];
            } else {
                segmentPath = dijkstra(graph, startKey, endKey);
            }
            
            if (!segmentPath) {
                valid = false;
                break;
            }
            
            if (i === 0) {
                fullPath.push(...segmentPath);
            } else {
                fullPath.push(...segmentPath);
            }
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –†–ê–°–ß–ï–¢ –†–ê–°–°–¢–û–Ø–ù–ò–Ø
            for (let j = 1; j < segmentPath.length; j++) {
                const a = segmentPath[j - 1];
                const b = segmentPath[j];
                totalDistance += calculateRealDistance(a, b);
            }
        }
        
        if (!valid) {
            document.getElementById('status').textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç';
            return;
        }
        
        // –°–æ–∑–¥–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç—ã –º–∞—Ä—à—Ä—É—Ç–∞ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏
        const routeSegments = [];
        for (let i = 0; i < fullPath.length - 1; i++) {
            const start = fullPath[i];
            const end = fullPath[i + 1];
            
            // –ù–∞—Ö–æ–¥–∏–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Å–µ–≥–º–µ–Ω—Ç –≤ –∏—Å—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            let segmentWeight = 5; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–≤–æ–±–æ–¥–Ω—ã–π –ø—Ä–æ—Ö–æ–¥
            
            for (const seg of segments) {
                if ((seg[0][0] === start[0] && seg[0][1] === start[1] && seg[1][0] === end[0] && seg[1][1] === end[1]) ||
                    (seg[0][0] === end[0] && seg[0][1] === end[1] && seg[1][0] === start[0] && seg[1][1] === start[1])) {
                    segmentWeight = seg[2];
                    break;
                }
            }
            
            let color;
            switch(segmentWeight) {
                case 1:
                    color = '#000000'; // –ß–µ—Ä–Ω—ã–π - –∑–∞–≤–∞–ª
                    break;
                case 2:
                    color = '#FF0000'; // –Ø—Ä–∫–æ-–∫—Ä–∞—Å–Ω—ã–π - —à–∫—É—Ä–æ–¥–µ—Ä
                    break;
                case 3:
                    color = '#FFA500'; // –û—Ä–∞–Ω–∂–µ–≤—ã–π - –ø—Ä–æ—Ö–æ–¥ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ–º
                    break;
                case 4:
                    color = '#0000FF'; // –°–∏–Ω–∏–π - –æ–±–≤–æ–¥–Ω–µ–Ω–Ω—ã–π —à—Ç—Ä–µ–∫
                    break;
                case 5:
                default:
                    color = '#00FF00'; // –ó–µ–ª–µ–Ω—ã–π - —Å–≤–æ–±–æ–¥–Ω—ã–π –ø—Ä–æ—Ö–æ–¥
            }
            
            routeSegments.push(L.polyline([[start[1], start[0]], [end[1], end[0]]], {
                color: color,
                weight: 6,
                opacity: 0.8,
                pane: 'routes'
            }));
        }

        // –°–æ–∑–¥–∞–µ–º –≥—Ä—É–ø–ø—É –¥–ª—è –≤—Å–µ—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –º–∞—Ä—à—Ä—É—Ç–∞
        routeLayer = L.layerGroup(routeSegments).addTo(map);
        
        document.getElementById('status').innerHTML =
            `–ú–∞—Ä—à—Ä—É—Ç: <span class="route-distance">${totalDistance.toFixed(1)} –º</span> (—Ç–æ—á–µ–∫: ${selectedPoints.length})`;
        
        try {
            const pointsGeoJsonText = await Android.loadPointsGeoJson();
            const pointsGeoJson = JSON.parse(pointsGeoJsonText);
            const nearbyPoints = findPointsNearRoute(fullPath, pointsGeoJson, 2.5);
            
            nearbyPoints.forEach(pt => {
                const circle = L.circle([pt.coords[1], pt.coords[0]], {
                    radius: 0.6,
                    color: '#5D4037',
                    fillColor: '#d4bc8c',
                    weight: 1.5,
                    fillOpacity: 1,
                    pane: 'markers'
                }).addTo(map);
                routePointMarkers.push(circle);
                
                const label = createLabelMarker(
                    [pt.coords[1], pt.coords[0]],
                    pt.name,
                    'route-point-label',
                    6,
                    -4
                );
                label.addTo(map);
                routeLabelMarkers.push(label);
            });
            
            routeLabelsVisible = true;
            toggleRouteLabels();
            updateLabelVisibility();
            
            if (nearbyPoints.length > 0) {
                const listHtml = nearbyPoints.map((p, idx) => {
                    const formattedName = formatTextWithLineBreaks(p.name);
                    return `<div class="route-point-item" data-lng="${p.coords[0]}" data-lat="${p.coords[1]}">‚Ä¢ ${formattedName}</div>`;
                }).join('');
                
                const popup = document.createElement('div');
                popup.id = 'route-points-popup';
                popup.innerHTML = `
                    <div style="
                        background: white;
                        padding: 12px;
                        border: 2px solid #aaffaa;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                        max-height: ${window.innerHeight / 3}px;
                        overflow-y: auto;
                        font-family: Calibri;
                        font-size: 13px;
                        position: fixed;
                        bottom: 80px;
                        right: 12px;
                        z-index: 2000;
                        max-width: 120px;
                    ">
                        <div style="font-weight: bold; margin-bottom: 8px; font-size: 13px;">–ù–∏—Ç–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞:</div>
                        <div>${listHtml}</div>
                    </div>
                `;
                document.body.appendChild(popup);
                currentRoutePointsPopup = popup;
                document.getElementById('show-route-points-btn').style.display = 'block';
                document.getElementById('show-route-points-btn').textContent = 'üëÅÔ∏è';
                
                popup.querySelectorAll('.route-point-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const el = e.target.closest('.route-point-item');
                        if (!el) return;
                        const lng = parseFloat(el.getAttribute('data-lng'));
                        const lat = parseFloat(el.getAttribute('data-lat'));
                        if (isNaN(lng) || isNaN(lat)) return;
                        map.setView([lat, lng], Math.max(map.getZoom(), 3));
                        if (window.temporaryHighlightMarker) {
                            map.removeLayer(window.temporaryHighlightMarker);
                        }
                        window.temporaryHighlightMarker = L.circle([lat, lng], {
                            radius: 2,
                            color: '#d32f2f',
                            fillColor: '#ff6b6b',
                            weight: 2,
                            fillOpacity: 1
                        }).addTo(map);
                        setTimeout(() => {
                            if (window.temporaryHighlightMarker) {
                                map.removeLayer(window.temporaryHighlightMarker);
                                window.temporaryHighlightMarker = null;
                            }
                        }, 2000);
                    });
                });
            } else {
                document.getElementById('show-route-points-btn').style.display = 'none';
                document.getElementById('show-route-points-btn').textContent = 'üìç';
            }
        } catch (e) {
            console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ—á–µ–∫:", e);
            document.getElementById('show-route-points-btn').style.display = 'none';
            document.getElementById('show-route-points-btn').textContent = 'üìç';
        }
        
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞:", error);
        document.getElementById('status').textContent = '–û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞';
    } finally {
        // –í–°–ï–ì–î–ê –°–ö–†–´–í–ê–ï–ú OVERLAY –ò –†–ê–ó–ë–õ–û–ö–ò–†–£–ï–ú –ò–ù–¢–ï–†–§–ï–ô–°
        console.log("–°–∫—Ä—ã–≤–∞–µ–º overlay –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞");
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.style.display = 'none';
        loadingOverlay.classList.remove('show');
        
        setUIEnabled(true);
        isBuildingRoute = false;
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –ø–æ –∫–∞—Ä—Ç–µ
  map.on('click', function(e) {
    if (menuOpen || segments.length === 0 || isBuildingRoute) return;
    const click = [e.latlng.lng, e.latlng.lat];
    const TOLERANCE = 4 * SCALE_CORRECTION; // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –¥–æ–ø—É—Å–∫
    let nearest = null;
    let minDist = Infinity;
    
    for (const node in graph) {
      const [x, y] = node.split(',').map(Number);
      const d = calculateRealDistance([x, y], click);
      if (d < minDist) {
        minDist = d;
        nearest = [x, y];
      }
    }
    
    if (!nearest || minDist > TOLERANCE) {
      document.getElementById('status').textContent = '–ö–ª–∏–∫ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –æ—Ç —Ç–æ–Ω–Ω–µ–ª–µ–π';
      return;
    }
    
    selectedPoints.push(nearest);
    const pointNumber = selectedPoints.length;
    const marker = L.circle([nearest[1], nearest[0]], {
      radius: 1,
      color: 'purple',
      fillColor: 'red',
      weight: 2,
      fillOpacity: 1,
      pane: 'markers'
    }).addTo(map);
    
    const label = createLabelMarker(
      [nearest[1], nearest[0]],
      String(pointNumber),
      'user-point-label',
      -7,
      0
    );
    label.addTo(map);
    
    pointMarkers.push(marker);
    userLabelMarkers.push(label);
    setTimeout(updateLabelVisibility, 100);
    
    pointMarkers.forEach((m, idx) => {
      let c = 'purple';
      if (idx === 0) c = 'green';
      else if (idx === pointMarkers.length - 1) c = 'blue';
      m.setStyle({ color: c });
    });
    
    if (selectedPoints.length === 1) {
      document.getElementById('status').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é —Ç–æ—á–∫—É –º–∞—Ä—à—Ä—É—Ç–∞';
    } else {
      buildFullRoute();
    }
    updateUndoButtonVisibility();
  });

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º–µ–Ω—é
  const menuButton = document.getElementById('menu-button');
  const dropdownMenu = document.getElementById('dropdown-menu');
  menuButton.addEventListener('click', (e) => {
    e.stopPropagation();
    menuOpen = !menuOpen;
    dropdownMenu.classList.toggle('active', menuOpen);
  });

  document.addEventListener('click', () => {
    if (menuOpen) {
      menuOpen = false;
      dropdownMenu.classList.remove('active');
    }
  });

  dropdownMenu.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  document.getElementById('clear-route-btn').addEventListener('click', clearRoute);

  document.getElementById('background-select').addEventListener('change', function(e) {
    if (mapBounds) {
      if (currentImageOverlay) map.removeLayer(currentImageOverlay);
      currentImageOverlay = L.imageOverlay(e.target.value, mapBounds, { opacity: 1 }).addTo(map);
    }
  });

  document.getElementById('save-route').addEventListener('click', () => {
    if (selectedPoints.length < 2) {
      alert('–ù–µ—Ç –º–∞—Ä—à—Ä—É—Ç–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 —Ç–æ—á–∫–∏)');
      return;
    }
    const routeName = document.getElementById('route-name').value.trim() || '–ú–æ–π –º–∞—Ä—à—Ä—É—Ç';
    const data = { version: 1, name: routeName, points: selectedPoints };
    const json = JSON.stringify(data, null, 2);
    Android.saveRoute(routeName, json);
    document.getElementById('route-name').value = '–ú–æ–π –º–∞—Ä—à—Ä—É—Ç';
    menuOpen = false;
    dropdownMenu.classList.remove('active');
  });

  document.getElementById('load-route').addEventListener('click', () => {
    Android.requestLoadRoute();
  });

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ –º–∞—Ä—à—Ä—É—Ç–∞
  document.getElementById('file-input').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      try {
        const data = JSON.parse(event.target.result);
        if (!data.points || !Array.isArray(data.points) || data.points.length < 2) {
          throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞');
        }
        clearRoute();
        selectedPoints = data.points.map(pt => [...pt]);
        selectedPoints.forEach((pt, idx) => {
          let color = 'purple';
          if (idx === 0) color = 'green';
          else if (idx === selectedPoints.length - 1) color = 'blue';
          const marker = L.circle([pt[1], pt[0]], {
            radius: 1,
            color: color,
            fillColor: 'red',
            weight: 2,
            fillOpacity: 1,
            pane: 'markers'
          }).addTo(map);
          const label = createLabelMarker(
            [pt[1], pt[0]],
            String(idx + 1),
            'user-point-label',
            -7,
            0
          );
          label.addTo(map);
          pointMarkers.push(marker);
          userLabelMarkers.push(label);
          setTimeout(updateLabelVisibility, 100);
        });
        buildFullRoute();
        if (data.name) {
          document.getElementById('route-name').value = data.name;
        }
        menuOpen = false;
        dropdownMenu.classList.remove('active');
      } catch (err) {
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–∞—Ä—à—Ä—É—Ç–∞: ' + err.message);
      }
    };
    reader.readAsText(file);
  });

  document.getElementById('show-route-points-btn').addEventListener('click', async () => {
    if (currentRoutePointsPopup) {
      currentRoutePointsPopup.remove();
      currentRoutePointsPopup = null;
      document.getElementById('show-route-points-btn').textContent = 'üìç';
      routeLabelsVisible = false;
      toggleRouteLabels();
    } else {
      try {
        const pointsGeoJsonText = await Android.loadPointsGeoJson();
        const pointsGeoJson = JSON.parse(pointsGeoJsonText);
        const coords = [];
        if (routeLayer && routeLayer.getLayers) {
          routeLayer.getLayers().forEach(layer => {
            const latlngs = layer.getLatLngs();
            if (latlngs.length >= 2) {
              coords.push([latlngs[0].lng, latlngs[0].lat]);
              coords.push([latlngs[1].lng, latlngs[1].lat]);
            }
          });
        }
        const nearbyPoints = findPointsNearRoute(coords, pointsGeoJson, 2.5);
        if (nearbyPoints.length > 0) {
          const listHtml = nearbyPoints.map((p, idx) => {
            const formattedName = formatTextWithLineBreaks(p.name);
            return `<div class="route-point-item" data-lng="${p.coords[0]}" data-lat="${p.coords[1]}">‚Ä¢ ${formattedName}</div>`;
          }).join('');
          const popup = document.createElement('div');
          popup.id = 'route-points-popup';
          popup.innerHTML = `
            <div style="
                background: white;
                padding: 12px;
                border: 2px solid #aaffaa;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                max-height: ${window.innerHeight / 3}px;
                overflow-y: auto;
                font-family: Calibri;
                font-size: 13px;
                position: fixed;
                bottom: 80px;
                right: 12px;
                z-index: 2000;
                max-width: 120px;
            ">
                <div style="font-weight: bold; margin-bottom: 8px; font-size: 13px;">–ù–∏—Ç–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞:</div>
                <div>${listHtml}</div>
            </div>
          `;
          document.body.appendChild(popup);
          currentRoutePointsPopup = popup;
          document.getElementById('show-route-points-btn').textContent = 'üëÅÔ∏è';
          routeLabelsVisible = true;
          toggleRouteLabels();
          popup.querySelectorAll('.route-point-item').forEach(item => {
            item.addEventListener('click', (e) => {
              const el = e.target.closest('.route-point-item');
              if (!el) return;
              const lng = parseFloat(el.getAttribute('data-lng'));
              const lat = parseFloat(el.getAttribute('data-lat'));
              if (isNaN(lng) || isNaN(lat)) return;
              map.setView([lat, lng], Math.max(map.getZoom(), 3));
              if (window.temporaryHighlightMarker) {
                map.removeLayer(window.temporaryHighlightMarker);
              }
              window.temporaryHighlightMarker = L.circle([lat, lng], {
                radius: 2,
                color: '#d32f2f',
                fillColor: '#ff6b6b',
                weight: 2,
                fillOpacity: 1
              }).addTo(map);
              setTimeout(() => {
                if (window.temporaryHighlightMarker) {
                  map.removeLayer(window.temporaryHighlightMarker);
                  window.temporaryHighlightMarker = null;
                }
              }, 2000);
            });
          });
        }
      } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ç–æ—á–µ–∫:", e);
      }
    }
  });

  // –ü–æ–∏—Å–∫
  async function performSearch(query) {
    const resultsContainer = document.getElementById('search-results');
    resultsContainer.innerHTML = '';
    if (!query.trim()) {
      resultsContainer.style.display = 'none';
      return;
    }
    
    if (!allPointsGeoJson) {
      try {
        const pointsText = await Android.loadPointsGeoJson();
        allPointsGeoJson = JSON.parse(pointsText);
      } catch (e) {
        console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–æ—á–∫–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞:", e);
        resultsContainer.style.display = 'none';
        return;
      }
    }
    
    const q = query.trim().toLowerCase();
    const matches = [];
    allPointsGeoJson.features.forEach(feature => {
      if (feature.geometry.type !== "Point") return;
      const name = feature.properties?.Name;
      const coords = feature.geometry.coordinates;
      if (!name || !coords || coords.length < 2) return;
      const nameLower = name.toLowerCase();
      if (nameLower.includes(q)) {
        let priority = 2;
        if (nameLower === q) priority = 0;
        else if (nameLower.startsWith(q)) priority = 1;
        matches.push({ name, coords, priority });
      }
    });
    
    if (matches.length === 0) {
      resultsContainer.style.display = 'none';
      return;
    }
    
    matches.sort((a, b) => {
      if (a.priority !== b.priority) return a.priority - b.priority;
      return a.name.localeCompare(b.name, 'ru');
    });
    
    matches.slice(0, 20).forEach(item => {
      const div = document.createElement('div');
      div.className = 'search-result-item';
      div.textContent = item.name;
      div.setAttribute('data-lng', item.coords[0]);
      div.setAttribute('data-lat', item.coords[1]);
      div.addEventListener('click', (e) => {
        const lng = parseFloat(e.target.getAttribute('data-lng'));
        const lat = parseFloat(e.target.getAttribute('data-lat'));
        if (!isNaN(lng) && !isNaN(lat)) {
          map.setView([lat, lng], Math.max(map.getZoom(), 3));
          if (window.temporaryHighlightMarker) {
            map.removeLayer(window.temporaryHighlightMarker);
          }
          window.temporaryHighlightMarker = L.circle([lat, lng], {
            radius: 2,
            color: '#d32f2f',
            fillColor: '#ff6b6b',
            weight: 2,
            fillOpacity: 1
          }).addTo(map);
          setTimeout(() => {
            if (window.temporaryHighlightMarker) {
              map.removeLayer(window.temporaryHighlightMarker);
              window.temporaryHighlightMarker = null;
            }
          }, 2000);
          document.getElementById('search-panel').style.display = 'none';
          document.getElementById('search-input').value = '';
        }
      });
      resultsContainer.appendChild(div);
    });
    resultsContainer.style.display = 'block';
  }

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞
  document.addEventListener('DOMContentLoaded', () => {
    const searchBtn = document.getElementById('search-btn');
    const searchInput = document.getElementById('search-input');
    const searchPanel = document.getElementById('search-panel');
    searchBtn.addEventListener('click', () => {
      const isVisible = searchPanel.style.display === 'block';
      if (!isVisible) {
        searchInput.value = '';
        searchPanel.style.display = 'block';
        searchInput.focus();
      } else {
        searchPanel.style.display = 'none';
      }
    });
    searchInput.addEventListener('input', (e) => {
      performSearch(e.target.value);
    });
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        searchPanel.style.display = 'none';
        searchInput.value = '';
      }
    });
    document.addEventListener('click', (e) => {
      if (!searchPanel.contains(e.target) && e.target !== searchBtn) {
        searchPanel.style.display = 'none';
      }
    });
  });

  // –õ–µ–≥–µ–Ω–¥–∞
  document.getElementById('legend-btn').addEventListener('click', () => {
    const legendPanel = document.getElementById('legend-panel');
    const isVisible = legendPanel.style.display === 'block';
    if (!isVisible) {
      legendPanel.style.display = 'block';
    } else {
      legendPanel.style.display = 'none';
    }
  });

  document.addEventListener('click', (e) => {
    const legendPanel = document.getElementById('legend-panel');
    const legendBtn = document.getElementById('legend-btn');
    if (!legendPanel.contains(e.target) && e.target !== legendBtn) {
      legendPanel.style.display = 'none';
    }
  });

  document.getElementById('show-disclaimer').addEventListener('click', () => {
    document.getElementById('disclaimer-overlay').style.display = 'flex';
    menuOpen = false;
    dropdownMenu.classList.remove('active');
  });

  document.getElementById('close-disclaimer').addEventListener('click', () => {
    document.getElementById('disclaimer-overlay').style.display = 'none';
  });

  document.getElementById('disclaimer-overlay').addEventListener('click', (e) => {
    if (e.target.id === 'disclaimer-overlay') {
      document.getElementById('disclaimer-overlay').style.display = 'none';
    }
  });

  function undoLastPoint() {
    if (selectedPoints.length === 0) return;
    selectedPoints.pop();
    const lastMarker = pointMarkers.pop();
    const lastLabel = userLabelMarkers.pop();
    if (lastMarker) map.removeLayer(lastMarker);
    if (lastLabel) map.removeLayer(lastLabel);
    
    pointMarkers.forEach((m, idx) => {
      let c = 'purple';
      if (idx === 0) c = 'green';
      else if (idx === pointMarkers.length - 1) c = 'blue';
      m.setStyle({ color: c });
    });
    
    userLabelMarkers.forEach(m => map.removeLayer(m));
    userLabelMarkers = [];
    pointMarkers.forEach((m, idx) => {
      const latlng = m.getLatLng();
      const label = createLabelMarker(
        [latlng.lat, latlng.lng],
        String(idx + 1),
        'user-point-label',
        -7,
        0
      );
      label.addTo(map);
      userLabelMarkers.push(label);
    });
    
    if (selectedPoints.length === 0) {
      clearRoute();
    } else if (selectedPoints.length === 1) {
      if (routeLayer) map.removeLayer(routeLayer);
      routeLayer = null;
      document.getElementById('status').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é —Ç–æ—á–∫—É –º–∞—Ä—à—Ä—É—Ç–∞';
      if (currentRoutePointsPopup) {
        currentRoutePointsPopup.remove();
        currentRoutePointsPopup = null;
      }
      document.getElementById('show-route-points-btn').style.display = 'none';
      document.getElementById('show-route-points-btn').textContent = 'üìç';
      routeLabelMarkers.forEach(m => map.removeLayer(m));
      routeLabelMarkers = [];
      routePointMarkers.forEach(m => map.removeLayer(m));
      routePointMarkers = [];
    } else {
      buildFullRoute();
    }
    updateUndoButtonVisibility();
    updateLabelVisibility();
  }

  document.getElementById('undo-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    undoLastPoint();
  });

  // === –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–ò –ö–ê–†–¢–´ ===
  async function initializeMap() {
    try {
      console.log("–ù–∞—á–∞–ª–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞—Ä—Ç—ã");
      
      const geoJsonText = await Android.loadGeoJson();
      console.log("GeoJSON –∑–∞–≥—Ä—É–∂–µ–Ω:", geoJsonText ? "–¥–∞" : "–Ω–µ—Ç");
      
      const data = JSON.parse(geoJsonText);
      console.log("GeoJSON –ø–∞—Ä—Å–∏—Ç—Å—è:", data.type);
      
      const allCoords = [];
      segments = [];
      graph = {};

      data.features.forEach(f => {
        if (!f.geometry) return;
        let lines = [];
        if (f.geometry.type === 'LineString') lines = [f.geometry.coordinates];
        else if (f.geometry.type === 'MultiLineString') lines = f.geometry.coordinates;
        else return;
        
        const weight = f.properties?.weight ?? 5;
        console.log(`–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ª–∏–Ω–∏—é —Å weight: ${weight}`);
        
        lines.forEach(coords => {
          if (coords.length < 2) return;
          coords.forEach(pt => allCoords.push(pt));
          for (let i = 0; i < coords.length - 1; i++) {
            const a = coords[i];
            const b = coords[i + 1];
            segments.push([a, b, weight]);
            const keyA = a.join(',');
            const keyB = b.join(',');
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –†–ê–°–ß–ï–¢ –°–¢–û–ò–ú–û–°–¢–ò –° –ö–ê–õ–ò–ë–†–û–í–ö–û–ô
            const baseLength = calculateRealDistance(a, b);
            let cost;
            
            if (weight === 1) {
              cost = Infinity;
            } else if (weight === 2) {
              cost = baseLength * 3;
            } else if (weight === 3) {
              cost = baseLength * 1.5;
            } else if (weight === 4) {
              cost = baseLength * 5;
            } else {
              cost = baseLength;
            }
            
            if (!graph[keyA]) graph[keyA] = {};
            if (!graph[keyB]) graph[keyB] = {};
            graph[keyA][keyB] = cost;
            graph[keyB][keyA] = cost;
          }
        });
      });

      console.log("–í—Å–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤:", segments.length);
      console.log("–í—Å–µ–≥–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:", allCoords.length);

      if (allCoords.length === 0) {
        console.error("GeoJSON –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç");
        document.getElementById('status').textContent = 'GeoJSON –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç';
        
        mapBounds = [
          [0, 0],
          [1000, 1000]
        ];
        map.fitBounds(mapBounds);
        
        currentImageOverlay = L.imageOverlay('maps/byaki.png', mapBounds, { 
          opacity: 1
        }).addTo(map);
        
      } else {
        const xs = allCoords.map(c => c[0]);
        const ys = allCoords.map(c => c[1]);
        mapBounds = [
          [Math.min(...ys), Math.min(...xs)],
          [Math.max(...ys), Math.max(...xs)]
        ];
        console.log("–ì—Ä–∞–Ω–∏—Ü—ã –∫–∞—Ä—Ç—ã:", mapBounds);
        
        map.fitBounds(mapBounds);
        
        currentImageOverlay = L.imageOverlay('maps/byaki.png', mapBounds, { 
          opacity: 1
        }).addTo(map);
        
        document.getElementById('status').textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å—Ö–µ–º—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ—á–µ–∫ –º–∞—Ä—à—Ä—É—Ç–∞';
      }

      updateUndoButtonVisibility();
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ—á–∫–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞
      try {
        const pointsText = await Android.loadPointsGeoJson();
        allPointsGeoJson = JSON.parse(pointsText);
        console.log("–¢–æ—á–∫–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã:", allPointsGeoJson.features.length);
      } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ—á–µ–∫ –¥–ª—è –ø–æ–∏—Å–∫–∞:", e);
      }
      
      console.log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω–∞");

    } catch (err) {
      console.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:", err);
      document.getElementById('status').textContent = '–û—à–∏–±–∫–∞: ' + (err.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
      
      const emergencyBounds = [
        [0, 0],
        [1000, 1000]
      ];
      map.fitBounds(emergencyBounds);
      L.rectangle(emergencyBounds, {
        color: "#ff3333",
        weight: 2,
        fillOpacity: 0.1
      }).addTo(map).bindPopup("–ê–≤–∞—Ä–∏–π–Ω—ã–π —Ä–µ–∂–∏–º").openPopup();
    }
  }

  // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ DOM
  document.addEventListener('DOMContentLoaded', initializeMap);
</script>
</body>
</html>
